import math
import random

import numpy as np
import click
from omegaconf import OmegaConf

from calt.dataset import DatasetPipeline
import sage.misc.randstate as randstate
from sage.misc.prandom import randint, choice
from sage.all import prime_range


class IntegerFactorizationGenerator:
    """
    Problem generator for integer factorization problems.

    This generator creates problems in which the problem is an integer n,
    and the solution is a list of prime factors of n in ascending order.
    The problem is generated by multiplying the solution factors.
    All prime factors will be less than or equal to prime_upper_bound.
    """

    def __init__(self, prime_upper_bound: int, min_factors: int, max_factors: int):
        """
        Initialize integer factorization generator.

        Args:
            prime_upper_bound: Upper bound for selecting prime numbers (inclusive)
            min_factors: Minimum number of prime factors
            max_factors: Maximum number of prime factors
        """
        self.prime_upper_bound = prime_upper_bound
        self.min_factors = min_factors
        self.max_factors = max_factors

        self.prime_lst = list(prime_range(2, self.prime_upper_bound + 1))

    def __call__(self, seed: int) -> tuple[int, list[int]]:
        """
        Generate a single sample.

        Each sample consists of:
        - Problem: integer n
        - Solution: list of prime factors in ascending order

        Args:
            seed: Seed for random number generator

        Returns:
            Tuple containing (n, factors)
        """
        # Set random seed for SageMath's random state
        randstate.set_random_seed(seed)

        # Choose number of factors for this sample
        num_factors = randint(self.min_factors, self.max_factors)

        # Generate random prime factors
        factors = [choice(self.prime_lst) for _ in range(num_factors)]

        # Sort factors in ascending order
        factors.sort()

        # Calculate problem integer by multiplying factors
        n = 1
        for p in factors:
            n *= p

        return n, factors


def integer_factor_stats_calc(problem, answer) -> dict[str, dict[str, int | float]]:
    return {"problem": _integer_stats(problem), "answer": _integer_list_stats(answer)}


def _integer_stats(data: int | float) -> dict[str, int | float]:
    if not data:
        raise ValueError("Cannot calculate statistics for empty data")
    return {"value": float(data)}


def _integer_list_stats(data: list[int | float]) -> dict[str, int | float]:
    if not data:
        raise ValueError("Cannot calculate statistics for empty data list")
    values = [float(n) for n in data]  # Convert to float for calculations
    stats = {
        "num_values": len(data),
        "min_value": min(values),
        "max_value": max(values),
        "mean_value": float(np.mean(values)),
        "std_value": float(np.std(values)),
    }
    return stats


@click.command()
@click.option(
    "--config_path",
    type=click.Path(exists=True),
    default="configs/data.yaml",
    help="Path to data config YAML (dataset).",
)
def main(config_path: str) -> None:
    cfg = OmegaConf.load(config_path)
    gen_cfg = OmegaConf.to_container(cfg.get("problem_generator", {}), resolve=True)
    if not gen_cfg:
        raise ValueError(
            "config must have 'problem_generator' with prime_upper_bound, min_factors, max_factors"
        )

    problem_generator = IntegerFactorizationGenerator(**gen_cfg)
    pipeline = DatasetPipeline.from_config(
        cfg.dataset,
        problem_generator=problem_generator,
        statistics_calculator=integer_factor_stats_calc,
    )
    pipeline.run()
    print("Dataset generation completed")


if __name__ == "__main__":
    main()
